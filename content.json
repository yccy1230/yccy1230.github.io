{"meta":{"title":"Michael's Blog","subtitle":null,"description":null,"author":"Michael Chen","url":"https://yccy1230.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-10-14T11:41:16.511Z","updated":"2018-10-13T15:28:27.948Z","comments":false,"path":"/404.html","permalink":"https://yccy1230.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-10-13T15:28:27.950Z","updated":"2018-10-13T15:28:27.950Z","comments":false,"path":"about/index.html","permalink":"https://yccy1230.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-10-13T17:01:32.561Z","updated":"2018-10-13T17:01:32.561Z","comments":false,"path":"books/index.html","permalink":"https://yccy1230.github.io/books/index.html","excerpt":"","text":"douban 豆瓣书单douban:user: 135750880 # 豆瓣用户名start: 0 # 从哪一条记录开始count: 100 # 获取豆瓣书单数据条数"},{"title":"友情链接","date":"2018-10-13T17:02:57.784Z","updated":"2018-10-13T17:02:57.784Z","comments":true,"path":"links/index.html","permalink":"https://yccy1230.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-10-13T17:00:06.660Z","updated":"2018-10-13T17:00:06.660Z","comments":false,"path":"repository/index.html","permalink":"https://yccy1230.github.io/repository/index.html","excerpt":"","text":"Githubgithub:username: yccy1230 # github username"},{"title":"标签","date":"2018-10-13T16:57:13.308Z","updated":"2018-10-13T15:28:27.953Z","comments":false,"path":"tags/index.html","permalink":"https://yccy1230.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-10-13T15:28:27.951Z","updated":"2018-10-13T15:28:27.951Z","comments":false,"path":"categories/index.html","permalink":"https://yccy1230.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"[图像处理]基于OpenCV对堆叠零件识别与定位","slug":"[图像处理]基于OpenCV对堆叠零件识别与定位","date":"2018-10-13T15:49:00.000Z","updated":"2018-10-14T16:18:14.514Z","comments":true,"path":"2018/10/13/[图像处理]基于OpenCV对堆叠零件识别与定位/","link":"","permalink":"https://yccy1230.github.io/2018/10/13/[图像处理]基于OpenCV对堆叠零件识别与定位/","excerpt":"","text":"一、项目介绍&emsp;&emsp;项目的目标正如标题所言，去识别堆叠零件中的可以被抓取的零件的位置，最后把数据输入到机械臂中实现零件的自动抓取。我们尝试了几种方法：通过机器学习的方式对图像中的零件进行勾勒，得到一批初始数据，通过将数据输入到yolo3框架中进行识别。这里数据的处理是一个很大的工作量，实验结果未出。尝试通过数字图像的方式进行处理，对零件形状进行检测识别。通过传统的机器学习（SVM）对图像进行分类&emsp;&emsp;我尝试的部分是后两者。附上需要处理的图像：二、项目基础OpenCV3.4 + VS2017 教程bilateralFilter双边滤波对图像进行平滑处理直方图均衡化图像增强Hough变换实现椭圆检测SVM(Support Vector Machine)支持向量机&emsp;&emsp;这些算法在opencv中都有进行实现，所以代码会比较简单。三、基本思路&emsp;基于传统数字图像的处理方式:&emsp;&emsp;1、对图像进行预处理，进行平滑（去噪）。&emsp;&emsp;2、直方图均衡化图像增强效果&emsp;&emsp;3、做二值化处理，为椭圆检测做铺垫&emsp;&emsp;4、执行椭圆检测&emsp;&emsp;5、绘制到原图上效果图：ps:测试图像上已经有三个红圈了，所以那几个位置会比较浓。详细对比一下一开始的原图。附录：部分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//1、通过双边滤波对图像进行平滑处理--去躁//2、直方图均衡化图像增强效果//3、做二值化处理//4、findContours寻找图像中的椭圆#include &quot;pch.h&quot;#include &lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/highgui/highgui.hpp&gt;#include&lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;vector&gt;using namespace cv;int ellipse(Mat image1);const char *fn = &quot;C:\\\\Users\\\\Michael Chen\\\\Desktop\\\\1.jpg&quot;;int main()&#123; Mat smooth,grad_x, grad_y; Mat abs_grad_x, abs_grad_y, dst; Mat origin = imread(fn); //imshow(&quot;origin&quot;, origin); // 图像平滑去躁 bilateralFilter(origin, smooth, 30, 30 * 2, 30 / 2); namedWindow(&quot;smooth&quot;, 0); imshow(&quot;smooth&quot;, smooth); Mat imageRGB[3]; split(smooth, imageRGB); for (int i = 0; i &lt; 3; i++) &#123; equalizeHist(imageRGB[i], imageRGB[i]); &#125; merge(imageRGB, 3, smooth); //imshow(&quot;直方图均衡化图像增强效果&quot;, smooth); ellipse(smooth); //二值化处理 Mat thresho; threshold(smooth, thresho, 35, 250, CV_THRESH_BINARY); //imshow(&quot;thresho&quot;, thresho); //// sober - x //Sobel(thresho, grad_x, CV_16S, 1, 0, 3, 1, 1, BORDER_DEFAULT); //convertScaleAbs(grad_x, abs_grad_x); //// sober - y //Sobel(thresho, grad_y, CV_16S, 0, 1, 3, 1, 1, BORDER_DEFAULT); //convertScaleAbs(grad_y, abs_grad_y); ////sober-x + sober-y //addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst); //imwrite(&quot;C:\\\\Users\\\\cheny\\\\Desktop\\\\sober.jpg&quot;, dst); //imshow(&quot;result&quot;, dst); waitKey(0); return 0;&#125;//#define minwidth 30Size2f a;const decltype(a.width) minwidth = 40; //if you dont know the type of width #define minheight 30 #define maxwidth 100#define maxheight 100double threshold1 = 130;double threshold2 = 200;int apertureSize = 3;//aperture size for the Sobel() operator.int point_num_min = 150; //least point in a contourint ellipse(Mat image1)&#123; cvtColor(image1, image1, CV_BGR2GRAY); GaussianBlur(image1, image1, Size(7, 7), 1.5, 1.5); Canny(image1, image1, threshold1, threshold2, apertureSize, false); namedWindow(&quot;canny_edge1&quot;, 0); imshow(&quot;canny_edge1&quot;, image1); std::vector&lt;std::vector&lt;Point&gt; &gt; contours1; std::vector&lt;RotatedRect&gt; contours01; findContours(image1, contours1, CV_RETR_LIST, CV_CHAIN_APPROX_NONE, cvPoint(0, 0)); Mat allcontours(image1.size(), CV_8U, Scalar(255)); contours01.reserve(contours1.size()); for (std::size_t k = 0; k &lt; contours1.size(); k++) &#123; int count = contours1[k].size(); // This is point&apos;s number in the contour if (count &gt; point_num_min) // the least points to form a contour contours01.push_back(fitEllipse(contours1[k])); &#125; drawContours(allcontours, contours1, -1, CV_RGB(0, 0, 0), 1,LINE_8, noArray(), contours1.size(), cvPoint(0, 0)); Size2f min; Size2f max; min.width = minwidth; min.height = minheight; max.width = maxwidth; max.height = maxheight; Mat origin = imread(fn, 1); for (auto a : contours01) &#123; auto ellipse_size = a.size; if ( ellipse_size.width &lt; max.width &amp;&amp; ellipse_size.height &lt; max.height &amp;&amp; ellipse_size.width &gt; min.width &amp;&amp; ellipse_size.height &gt; min.height ) &#123; ellipse(origin, a, CV_RGB(255,0,0),2); std::cout &lt;&lt; &quot;size = &quot; &lt;&lt; a.size &lt;&lt; &quot; , &quot; &lt;&lt; &quot;center =&quot; &lt;&lt; a.center &lt;&lt; std::endl; &#125; &#125; namedWindow(&quot;drawcontour&quot;, 0); namedWindow(&quot;ellipsecontour&quot;, 0); imshow(&quot;drawcontour&quot;, allcontours); imshow(&quot;ellipsecontour&quot;, origin); waitKey(0); return 0;&#125;","categories":[],"tags":[]}]}